const api = require("../middleware/API")
const {PlayerInfo, PlayerStatus, Country, Player, Buildings, Keys} = require("../database/Models");
const Data = require("../models/CacheData");
const ErrorHandler = require("../error/ErrorHandler")
const keyboard = require("../variables/Keyboards")
const NameLibrary = require("../variables/NameLibrary");
const Prices = require("../variables/Prices");
class CallbackEventController
{
    async Handler(context)
    {
        context.eventPayload?.command === "merry" && await this.Merry(context)
        context.eventPayload?.command  === "decline_merry" && await this.DeclineMerry(context)
        context.eventPayload?.command === "divorce" && await this.Divorce(context)
        context.eventPayload?.command === "decline_divorce" && await this.DeclineDivorce(context)
        context.eventPayload?.command === "give_citizenship" && await this.GiveCitizenship(context)
        context.eventPayload?.command === "decline_citizenship" && await this.DeclineCitizenship(context)
        context.eventPayload?.command === "give_registration" && await this.GiveRegistration(context)
        context.eventPayload?.command === "decline_registration" && await this.DeclineRegistration(context)
        context.eventPayload?.command === "allow_user_building" && await this.AllowUserBuilding(context)
        context.eventPayload?.command === "decline_user_building" && await this.DeclineUserBuilding(context)
    }

    async Merry(context)
    {
        const firstUserID = context.peerId
        const firstUser = Data.users[firstUserID]
        const secondUserID = context.eventPayload.item
        const secondUser = Data.users[secondUserID]
        try
        {
            await PlayerInfo.update(
                {
                    marriedID: secondUserID
                },
                {where: {id: firstUserID}})
            Data.users[firstUserID].marriedID = secondUserID
            Data.users[firstUserID].isMarried = true
            await PlayerInfo.update(
                {
                    marriedID: firstUserID
                },
                {where: {id: secondUserID}})
            Data.users[secondUserID].marriedID = firstUserID
            Data.users[secondUserID].isMarried = true
            await api.api.messages.edit({
                peer_id: context.peerId,
                message: "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ",
                conversation_message_id: context.conversationMessageId,
                keyboard: keyboard.inlineNone
            })
            await api.SendMessage(firstUserID, `‚ù§ –¢–µ–ø–µ—Ä—å *id${secondUser.id}(${secondUser.nick}) –≤–∞—à${secondUser.gender ? " –º—É–∂" : "–∞ –∂–µ–Ω–∞"}`)
            await api.SendMessage(secondUserID, `‚ù§ –¢–µ–ø–µ—Ä—å *id${firstUser.id}(${firstUser.nick}) –≤–∞—à${firstUser.gender ? " –º—É–∂" : "–∞ –∂–µ–Ω–∞"}`)
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –ø—Ä–∏–Ω—è—Ç–∏—è –±—Ä–∞–∫–∞", e)
        }
    }

    async DeclineMerry(context)
    {
        const firstUserID = context.peerId
        const firstUser = Data.users[firstUserID]
        const secondUserID = context.eventPayload.item
        const secondUser = Data.users[secondUserID]
        try
        {
            Data.users[secondUserID].isMarried = false
            await api.api.messages.edit({
                peer_id: context.peerId,
                message: "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ",
                conversation_message_id: context.conversationMessageId,
                keyboard: keyboard.inlineNone
            })
            await api.SendMessage(firstUserID, `üíî –í—ã –æ—Ç–≤–µ—Ä–≥–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –±—Ä–∞–∫–∞ –æ—Ç –∏–≥—Ä–æ–∫–∞ *id${secondUser.id}(${secondUser.nick})`)
            await api.SendMessage(secondUserID, `üíî *id${firstUser.id}(${firstUser.nick}) ${firstUser.gender ? "–æ—Ç–≤–µ—Ä–≥" : "–æ—Ç–≤–µ—Ä–≥–ª–∞"} –≤–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤—Å—Ç—É–ø–∏—Ç—å –≤ –±—Ä–∞–∫.`)
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ—Ç–≤–µ—Ä–∂–µ–Ω–∏—è –±—Ä–∞–∫–∞", e)
        }
    }

    async Divorce(context)
    {
        const firstUserID = context.peerId
        const firstUser = Data.users[firstUserID]
        const secondUserID = context.eventPayload.item
        const secondUser = Data.users[secondUserID]
        try
        {
            await PlayerInfo.update(
                {
                    marriedID: null
                },
                {where: {id: firstUserID}})
            Data.users[firstUserID].marriedID = null
            Data.users[firstUserID].isMarried = false
            await PlayerInfo.update(
                {
                    marriedID: null
                },
                {where: {id: secondUserID}})
            Data.users[secondUserID].marriedID = null
            Data.users[secondUserID].isMarried = false
            await api.api.messages.edit({
                peer_id: context.peerId,
                message: "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ",
                conversation_message_id: context.conversationMessageId,
                keyboard: keyboard.inlineNone
            })
            await api.SendMessage(firstUserID, `üíî –ë–æ–ª—å—à–µ *id${secondUser.id}(${secondUser.nick}) –Ω–µ –≤–∞—à${secondUser.gender ? " –º—É–∂" : "–∞ –∂–µ–Ω–∞"}`)
            await api.SendMessage(secondUserID, `üíî –ë–æ–ª—å—à–µ *id${firstUser.id}(${firstUser.nick}) –Ω–µ –≤–∞—à${firstUser.gender ? " –º—É–∂" : "–∞ –∂–µ–Ω–∞"}`)
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–∞—Å—Ç–æ—Ä–∂–µ–Ω–∏—è –±—Ä–∞–∫–∞", e)
        }
    }

    async DeclineDivorce(context)
    {
        const firstUserID = context.peerId
        const firstUser = Data.users[firstUserID]
        const secondUserID = context.eventPayload.item
        const secondUser = Data.users[secondUserID]
        try
        {
            await api.api.messages.edit({
                peer_id: context.peerId,
                message: "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ",
                conversation_message_id: context.conversationMessageId,
                keyboard: keyboard.inlineNone
            })
            await api.SendMessage(firstUserID, `‚ù§ –í—ã –æ—Ç–≤–µ—Ä–≥–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ä–∞—Å—Ç–æ—Ä–∂–µ–Ω–∏—è –±—Ä–∞–∫–∞ –æ—Ç –∏–≥—Ä–æ–∫–∞ *id${secondUser.id}(${secondUser.nick})`)
            await api.SendMessage(secondUserID, `‚ù§ *id${firstUser.id}(${firstUser.nick}) ${firstUser.gender ? "–æ—Ç–≤–µ—Ä–≥" : "–æ—Ç–≤–µ—Ä–≥–ª–∞"} –≤–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —Ä–∞—Å—Ç–æ—Ä–≥–Ω—É—Ç—å –±—Ä–∞–∫.`)
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ—Ç–≤–µ—Ä–∂–µ–Ω–∏—è —Ä–∞—Å—Ç–æ—Ä–∂–µ–Ω–∏—è –±—Ä–∞–∫–∞", e)
        }
    }

    async GiveCitizenship(context)
    {
        const secondUserID = context.eventPayload.item
        const countryID = context.eventPayload.addition
        try
        {
            if(Data.users[secondUserID].waitingCitizenship)
            {
                clearTimeout(Data.users[secondUserID].waitingCitizenship)
                await PlayerStatus.update({citizenship: countryID},{where: {id: secondUserID}})
                if(!context.player.status.match(/worker/))
                {
                    await Player.update({status: "stateless"},{where: {id: context.player.id}})
                }
                Data.users[secondUserID].citizenship = countryID
                if(Data.users[secondUserID].status !== "worker")
                {
                    Data.users[secondUserID].status = "citizen"
                    await Player.update({status: "citizen"}, {where: {id: secondUserID}})
                }
                const country = await Country.findOne({where: {id: countryID}})
                country.set({population: country.population + 1})
                await country.save()
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
                await api.SendMessage(secondUserID, `‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –≥—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–æ –ø—Ä–∏–Ω—è—Ç–∞.`, [[keyboard.backButton]])
            }
            else
            {
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ö† –ù–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
            }
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ–¥–æ–±—Ä–µ–Ω–∏—è –≥—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–∞", e)
        }
    }

    async DeclineCitizenship(context)
    {
        const secondUserID = context.eventPayload.item
        const citizen = Data.users[secondUserID]
        try
        {
            if(citizen.waitingCitizenship)
            {
                clearTimeout(Data.users[secondUserID].waitingCitizenship)
                if(Data.users[secondUserID].status !== "worker")
                {
                    Data.users[secondUserID].status = "stateless"
                }
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
                await api.SendMessage(secondUserID, `‚ùå –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –≥—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.`)
            }
            else
            {
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ö† –ù–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
            }
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ—Ç–≤–µ—Ä–∂–µ–Ω–∏—è –≥—Ä–∞–∂–¥–∞–Ω—Å—Ç–≤–∞", e)
        }
    }

    async GiveRegistration(context)
    {
        const secondUserID = context.eventPayload.item
        const cityID = context.eventPayload.addition
        try
        {
            if(Data.users[secondUserID].waitingRegistration)
            {
                clearTimeout(Data.users[secondUserID].waitingRegistration)
                await PlayerInfo.update({registration: cityID},{where: {id: secondUserID}})
                Data.users[secondUserID].registration = cityID
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
                await api.SendMessage(secondUserID, `‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞. –¢–µ–ø–µ—Ä—å –≤—ã –ø—Ä–æ–ø–∏—Å–∞–Ω—ã –≤ –≥–æ—Ä–æ–¥–µ ${Data.GetCityName(cityID)}`, [[keyboard.backButton]])
            }
            else
            {
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ö† –ù–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
            }
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ–¥–æ–±—Ä–µ–Ω–∏—è –ø—Ä–æ–ø–∏—Å–∫–∏", e)
        }
    }

    async DeclineRegistration(context)
    {
        const secondUserID = context.eventPayload.item
        const citizen = Data.users[secondUserID]
        try
        {
            if(citizen.waitingRegistration)
            {
                clearTimeout(Data.users[secondUserID].waitingRegistration)
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
                await api.SendMessage(secondUserID, `‚ùå –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ–ø–∏—Å–∫–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.`)
            }
            else
            {
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ö† –ù–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
            }
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ—Ç–≤–µ—Ä–∂–µ–Ω–∏—è –ø—Ä–æ–ø–∏—Å–∫–∏", e)
        }
    }

    async AllowUserBuilding(context)
    {
        const userID = context.eventPayload.item
        const buildingID = context.eventPayload.addition
        try
        {
            let isActual = false
            let timeoutNum = null
            if(Data.users[userID]?.waitingAllowBuilding)
            {
                for(let i = 0; i < Data.users[userID]?.waitingAllowBuilding.length; i++)
                {
                    if(Data.users[userID]?.waitingAllowBuilding[i][0])
                    if(Data.users[userID]?.waitingAllowBuilding[i][0] === buildingID)
                    {
                        isActual = true
                        timeoutNum = i
                    }
                }
            }
            if(isActual)
            {
                clearTimeout(Data.users[userID]?.waitingAllowBuilding[timeoutNum][1])
                delete Data.users[userID]?.waitingAllowBuilding[timeoutNum]
                const building = await Buildings.findOne({where: {id: buildingID}})
                await Keys.create({
                    houseID: building.dataValues.id,
                    ownerID: userID,
                    name: "üîë " + building.dataValues.name,
                    description: "–ö–ª—é—á –æ—Ç –ø–æ—Å—Ç—Ä–æ–π–∫–∏ - " + NameLibrary.GetBuildingType(building.dataValues.type) + " –≤ –≥–æ—Ä–æ–¥–µ " + Data.GetCityName(building.dataValues.cityID)
                })
                building.set({freezing: false})
                await building.save()
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
                await api.SendMessage(userID, `‚úÖ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞. –¢–µ–ø–µ—Ä—å –≤—ã –≤–ª–∞–¥–µ–ª–µ—Ü –ø–æ—Å—Ç—Ä–æ–π–∫–∏ ${NameLibrary.GetBuildingType(building.dataValues.type)} –≤ –≥–æ—Ä–æ–¥–µ ${Data.GetCityName(building.dataValues.cityID)}`, [[keyboard.backButton]])
            }
            else
            {
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ö† –ù–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
            }
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ–¥–æ–±—Ä–µ–Ω–∏—è –ø—Ä–æ–ø–∏—Å–∫–∏", e)
        }
    }

    async DeclineUserBuilding(context)
    {
        const userID = context.eventPayload.item
        const buildingID = context.eventPayload.addition
        try
        {
            let isActual = false
            let timeoutNum = null
            if(Data.users[userID]?.waitingAllowBuilding)
            {
                for(let i = 0; i < Data.users[userID]?.waitingAllowBuilding.length; i++)
                {
                    if(Data.users[userID]?.waitingAllowBuilding[i][0])
                    if(Data.users[userID]?.waitingAllowBuilding[i][0] === buildingID)
                    {
                        isActual = true
                        timeoutNum = i
                    }
                }
            }
            if(isActual)
            {
                clearTimeout(Data.users[userID]?.waitingAllowBuilding[timeoutNum][1])
                delete Data.users[userID]?.waitingAllowBuilding[timeoutNum]
                const building = await Buildings.findOne({where: {id: buildingID}})
                await Buildings.destroy({where: {id: buildingID}})
                const price = NameLibrary.ReversePrice(Prices["new_" + building.dataValues.type.replace("building_of_", "")])
                await Data.AddPlayerResources(userID, price)
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
                await api.SendMessage(userID, `‚ùå –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –≤ –≥–æ—Ä–æ–¥–µ –ø–æ—Å—Ç—Ä–æ–π–∫–∏ ${NameLibrary.GetBuildingType(building.dataValues.type)} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞. –ì–ª–∞–≤–∞ –≥–æ—Ä–æ–¥–∞ –Ω–µ –¥–∞–ª –æ–¥–æ–±—Ä–µ–Ω–∏–µ –Ω–∞ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ. –†–µ—Å—É—Ä—Å—ã –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.`, [[keyboard.backButton]])
            }
            else
            {
                await api.api.messages.edit({
                    peer_id: context.peerId,
                    message: "‚ö† –ù–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ",
                    conversation_message_id: context.conversationMessageId,
                    keyboard: keyboard.inlineNone
                })
            }
        }
        catch (e)
        {
            await ErrorHandler.SendLogs(context, "–°–æ–±—ã—Ç–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è ", e)
        }
    }
}

module.exports = new CallbackEventController()